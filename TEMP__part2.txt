            content_w = min(natural_w, max_content_w)
            label.setTextWidth(content_w)

            opt = label.document().defaultTextOption()
            opt.setAlignment(Qt.AlignmentFlag.AlignHCenter)
            opt.setWrapMode(QTextOption.WrapMode.WordWrap)
            label.document().setDefaultTextOption(opt)
            label.document().setDocumentMargin(0)

            br = label.boundingRect()

            bw = min(max_label_w, br.width() + 2 * padx)
            bh = br.height() + 2 * pady

            bx = max(float(safe_pad), min(float(vw - bw - safe_pad), x - bw / 2))

            above_rect = QRectF(bx, y0 - label_gap - bh, bw, bh)
            below_rect = QRectF(bx, y0 + label_gap,   bw, bh)

            preferred_side = next_side
            alternate_side = "below" if preferred_side == "above" else "above"

            def _has_overlap(rect: QRectF, items: List[QRectF]) -> bool:
                return any(rect.intersects(other) for other in items)

            candidates = {"above": above_rect, "below": below_rect}
            side = preferred_side
            if _has_overlap(candidates[side], last_label_rects[side]):
                if not _has_overlap(candidates[alternate_side], last_label_rects[alternate_side]):
                    side = alternate_side
                else:
                    overlap_pref = self._overlap_amount(candidates[side], last_label_rects[side])
                    overlap_alt = self._overlap_amount(candidates[alternate_side], last_label_rects[alternate_side])
                    side = alternate_side if overlap_alt < overlap_pref else preferred_side

            bubble_rect = candidates[side]
            bubble_rect = QRectF(
                bubble_rect.x(),
                max(float(safe_pad), min(float(vh - bh - safe_pad), bubble_rect.y())),
                bubble_rect.width(),
                bubble_rect.height(),
            )

            bubble_rect = self._resolve_label_overlap(
                rect=bubble_rect,
                others=last_label_rects[side],
                x_min=float(safe_pad),
                x_max=float(vw - safe_pad - bubble_rect.width()),
                preferred_center=float(x),
            )

            last_label_rects[side].append(bubble_rect)
            next_side = "below" if side == "above" else "above"

            # Bubble
            cat_color = color_for(ev.categoria)
            bubble = BubbleItem(bubble_rect, radius=10.0, bg_color=cat_color, alpha=BUBBLE_BG_ALPHA)
            self.scene.addItem(bubble)

            # Testo
            label.setPos(bubble_rect.x() + padx, bubble_rect.y() + pady)
            label.setZValue(1.0)
            label.setToolTip(f"{ev.titolo}\n{ev.categoria}\n{ev.dt:%Y-%m-%d}")
            self.scene.addItem(label)

            # Connettore
            pen_conn = QPen(QColor("#9aa4ae"), 1)
            if side == "above":
                y1, y2 = bubble_rect.y() + bubble_rect.height(), y0
            else:
                y1, y2 = y0, bubble_rect.y()
            vline = QGraphicsLineItem(x, y1, x, y2)
            vline.setPen(pen_conn)
            vline.setZValue(0.2)
            self.scene.addItem(vline)

            # Data opposta, clampata ai bordi
            date_side = "below" if side == "above" else "above"
            self._draw_date_opposite_clamped(
                x=x, y_axis=y0, d=ev.dt, font=date_font,
                side=date_side, gap=date_gap,
                vw=vw, vh=vh, safe_pad=safe_pad
            )

        # NIENTE fitInView: lasciamo la scena 1:1 con la viewport
        # self.fitInView(...)

    # ---------- Primitive ----------
    def _draw_date_opposite_clamped(
        self, x: float, y_axis: float, d: datetime, font: QFont,
        side: Literal["above", "below"], gap: int,
        vw: int, vh: int, safe_pad: int
    ) -> None:
        txt = QGraphicsTextItem(d.strftime("%Y-%m-%d"))
        txt.setDefaultTextColor(QColor("#6b7280"))
        txt.setFont(font)
        rect = txt.boundingRect()

        if side == "below":
            y_text = y_axis + gap + 18
        else:
            y_text = y_axis - rect.height() - gap - 18

        # Clamp orizzontale e verticale
        x_text = max(float(safe_pad), min(float(vw - rect.width() - safe_pad), x - rect.width() / 2))
        y_text = max(float(safe_pad), min(float(vh - rect.height() - safe_pad), y_text))

        txt.setPos(x_text, y_text)
        txt.setZValue(0.3)
        self.scene.addItem(txt)

    def _try_draw_icon(self, x: float, top_y: float, ev: Event, icon_size: int, is_future: bool) -> bool:
        cat_key = (ev.categoria or "").strip().lower()
        path = self.icon_map.get(cat_key)
        if not path:
            return False
        pix = QPixmap(path)
        if pix.isNull():
            return False
        pix = pix.scaled(
            icon_size, icon_size,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation
        )
        it = QGraphicsPixmapItem(pix)
        it.setOffset(x - pix.width() / 2, top_y)
        it.setOpacity(self.future_opacity if is_future else 1.0)
        it.setZValue(2.0)
        it.setToolTip(f"{ev.titolo}\n{ev.categoria}\n{ev.dt:%Y-%m-%d}")
        self.scene.addItem(it)
        return True

    def _draw_circle(self, x: float, top_y: float, ev: Event, icon_size: int, is_future: bool) -> None:
        r = icon_size / 2
        c = color_for(ev.categoria)
        alpha_f = self.future_opacity if is_future else 1.0

        border = QColor(c); border.setAlphaF(alpha_f)
        fill   = QColor(c); fill.setAlphaF(alpha_f)

        pen = QPen(border)
        pen.setWidth(max(2, int(icon_size * 0.12)))

        circle = QGraphicsEllipseItem(x - r, top_y, 2 * r, 2 * r)
        circle.setPen(pen)
        circle.setBrush(QBrush(fill))
        circle.setOpacity(1.0)
        circle.setZValue(2.0)
        circle.setToolTip(f"{ev.titolo}\n{ev.categoria}\n{ev.dt:%Y-%m-%d}")
        self.scene.addItem(circle)

    # ---------- Utility ----------
    def _overlap_amount(self, rect: QRectF, others: List[QRectF]) -> float:
        total = 0.0
        for other in others:
            inter = rect.intersected(other)
            if not inter.isNull():
                total += inter.width() * inter.height()
        return total

    def _resolve_label_overlap(
        self,
        rect: QRectF,
        others: List[QRectF],
        x_min: float,
        x_max: float,
        preferred_center: float,
    ) -> QRectF:
        """Sposta la label in orizzontale per evitare sovrapposizioni con quelle già disegnate."""

        result = QRectF(rect)
        gap = max(6.0, rect.height() * 0.15)

        def overlaps_any(r: QRectF) -> List[QRectF]:
            return [o for o in others if r.intersects(o)]

        attempts = 0
        overlapping = overlaps_any(result)
        while overlapping and attempts < 16:
            attempts += 1
            shift_right = max((o.right() + gap) - result.left() for o in overlapping)
            shift_left = max(result.right() - (o.left() - gap) for o in overlapping)

            cand_right = QRectF(result)
            cand_right.translate(shift_right, 0.0)
            cand_left = QRectF(result)
            cand_left.translate(-shift_left, 0.0)

            valid_right = cand_right.left() <= x_max
            valid_left = cand_left.left() >= x_min

            if valid_right and valid_left:
                center_right = cand_right.center().x()
                center_left = cand_left.center().x()
                if abs(center_right - preferred_center) <= abs(center_left - preferred_center):
                    result = cand_right
                else:
                    result = cand_left
            elif valid_right:
                result = cand_right
            elif valid_left:
                result = cand_left
            else:
                break

            new_left = max(x_min, min(result.left(), x_max))
            result.moveLeft(new_left)
            overlapping = overlaps_any(result)

        if result.left() < x_min:
            result.moveLeft(x_min)
        if result.left() > x_max:
            result.moveLeft(x_max)

        return result

    # ---------- Font helpers ----------

    def _make_font(self, size: int, prefer: List[str]) -> QFont:
        """Crea un QFont scegliendo il peso migliore disponibile secondo l’ordine preferito."""
        weight_map = {
            "Light":    QFont.Weight.Light,
            "Normal":   QFont.Weight.Normal,
            "Medium":   QFont.Weight.Medium,
            "DemiBold": QFont.Weight.DemiBold,
            "Bold":     QFont.Weight.Bold,
            "Black":    QFont.Weight.Black,
        }
        chosen = None
        for w in prefer:
            if w in self.available_weights:
                chosen = w
                break
        if chosen is None:
            chosen = "Normal"

        f = QFont(self.font_family, size)
        f.setWeight(weight_map[chosen])
        return f
